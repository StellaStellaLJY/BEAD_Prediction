# -*- coding: utf-8 -*-
"""BEAD_Prediction

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1q40hlpMmShG25DiBu0OloCVG4ZBM_0hI
"""

import pandas as pd
from datetime import datetime
import urllib.request
import sys

import json

station_mapping = pd.read_csv("station_mapping.csv")

try:
  ResultBytes = urllib.request.urlopen("https://weather.visualcrossing.com/VisualCrossingWebServices/rest/services/timeline/chicago/next24hours?unitGroup=us&elements=datetime%2Ctemp%2Cprecip%2Cpreciptype%2Cwindspeed%2Cuvindex%2Cicon&include=hours%2Ccurrent&key=AAKHVD69CLXCJ4UNBZ69L9RPM&contentType=json")

  # Parse the results as JSON
  jsonData = json.load(ResultBytes)

except urllib.error.HTTPError  as e:
  ErrorInfo= e.read().decode()
  print('Error code: ', e.code, ErrorInfo)
  sys.exit()
except  urllib.error.URLError as e:
  ErrorInfo= e.read().decode()
  print('Error code: ', e.code,ErrorInfo)
  sys.exit()

# 提取小时数据
hourly_data = jsonData["days"][0]["hours"]
date_str = jsonData["days"][0]["datetime"]  # 日期，例如 '2025-04-22'

# 转换为 DataFrame
df = pd.DataFrame(hourly_data)

# 把 preciptype 列表处理成单值字符串（或 None）
df["preciptype"] = df["preciptype"].apply(lambda x: x[0] if isinstance(x, list) else x)

# 创建完整时间戳
df["timestamp"] = pd.to_datetime(date_str + " " + df["datetime"])

# 时间衍生变量
df["year"] = df["timestamp"].dt.year
df["month"] = df["timestamp"].dt.month
df["day_of_week"] = df["timestamp"].dt.dayofweek
df["hour"] = df["timestamp"].dt.hour
df["is_weekend"] = df["day_of_week"].apply(lambda x: 1 if x >= 5 else 0)
df["year_month"] = df["timestamp"].dt.to_period("M").astype(str)
df["time_index"] = (df["timestamp"] - pd.Timestamp("2000-01-01")).dt.days

# 创建 precip_rain / precip_snow 特征
df["precip_rain"] = df["preciptype"].apply(lambda x: 1 if x == "rain" else 0)
df["precip_snow"] = df["preciptype"].apply(lambda x: 1 if x == "snow" else 0)

# 选择需要的列（顺序可调整）
final_df = df[[
    "temp", "precip", "windspeed", "uvindex", "icon",
    "year", "month", "day_of_week", "hour", "is_weekend",
    "year_month", "time_index", "precip_rain", "precip_snow"
]]

# 展示前几行
print(final_df.head())

# 1. 添加关键字段，使得可以做“笛卡尔积”
df['key'] = 1
station_mapping['key'] = 1

# 2. 执行笛卡尔积
X = pd.merge(df, station_mapping, on='key')

# 3. 删除辅助 key 列
X = X.drop(columns=['key'])

# 编码类别变量
categorical_cols = ["icon"]
X[categorical_cols] = X[categorical_cols].astype("category")
X[categorical_cols] = X[categorical_cols].apply(lambda x: x.cat.codes)

X.head(5)

print(X.dtypes)

desired_cols = [
    'timestamp', 'lat', 'lng', 'temp', 'precip',
    'windspeed', 'uvindex', 'icon', 'year', 'month', 'day_of_week',
    'hour', 'is_weekend', 'year_month', 'time_index',
    'precip_rain', 'precip_snow'
]

# 调整列顺序
X = X[desired_cols]

timestamps = X['timestamp']
X_no_timestamp = X.drop(columns=['timestamp'])
X_no_timestamp = X_no_timestamp.select_dtypes(include=["number"])  # 保证全是数值

print(X_no_timestamp.dtypes)

import joblib
import pandas as pd

# 加载模型
model = joblib.load("xgb_model_CV_4.0.pkl")


# 模型预测并取整
X['predicted_inventory_change'] = model.predict(X_no_timestamp).round().astype(int)

X['timestamp'] = timestamps  # 加回来
X = X[[
    'timestamp', 'lat', 'lng', 'temp', 'precip',
    'windspeed', 'uvindex', 'icon', 'year', 'month', 'day_of_week',
    'hour', 'is_weekend', 'year_month', 'time_index',
    'precip_rain', 'precip_snow', 'predicted_inventory_change'
]]

X.head(5)

X = X.merge(station_mapping, on=['lat', 'lng'], how='left')

X.head(5)